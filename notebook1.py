# -*- coding: utf-8 -*-
"""Copy of Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ubypaKUfkH-PSZNBZaOMCJMHDiazjvPn
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def show_image(image, title="Image"):
    """Helper function to display images during processing"""
    plt.figure(figsize=(10, 6))
    if len(image.shape) == 3:
        plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    else:
        plt.imshow(image, cmap='gray')
    plt.title(title)
    plt.axis('off')
    plt.show()

def preprocess_image(image_path):
    # Read the image
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Could not read image at {image_path}")

    # Create a copy of the original image
    original = image.copy()

    # grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Gaussian blur
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # threshold
    _, thresh = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    return original, gray, thresh

def find_bubbles(thresh_image):
    """Find all potential bubbles (circles) in the image"""
    # Find contours
    contours, _ = cv2.findContours(thresh_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter contours to keep only those that are likely to be bubbles
    bubbles = []
    for contour in contours:
        # Calculate area and perimeter
        area = cv2.contourArea(contour)
        perimeter = cv2.arcLength(contour, True)

        # Filter based on area and circularity
        if area > 50:

            circularity = 4 * np.pi * area / (perimeter * perimeter)

            if circularity > 0.6:
                # Get bounding rectangle
                x, y, w, h = cv2.boundingRect(contour)

                # Check if it's approximately square
                aspect_ratio = w / float(h)
                if 0.7 <= aspect_ratio <= 1.3:
                    bubbles.append((x, y, w, h, contour, area))

    return bubbles

def organize_bubbles(bubbles, num_questions=5, num_options=4):
    # Sort bubbles by y-coordinate
    bubbles_with_centers = [(x, y, w, h, contour, area, y + h//2) for x, y, w, h, contour, area in bubbles]

    # Find average bubble area
    if bubbles_with_centers:
        avg_area = sum(b[5] for b in bubbles_with_centers) / len(bubbles_with_centers)
        # Filter out bubbles that are significantly smaller or larger than average
        bubbles_with_centers = [b for b in bubbles_with_centers if 0.3 * avg_area <= b[5] <= 2.0 * avg_area]

    # If no bubbles left after filtering, return an empty list
    if not bubbles_with_centers:
        return []

    # Sort by y-center first
    bubbles_with_centers.sort(key=lambda bubble: bubble[6])

    # Use a more robust approach to group bubbles into rows
    # Calculate the average height between consecutive bubbles to determine a dynamic threshold
    y_diffs = [bubbles_with_centers[i+1][6] - bubbles_with_centers[i][6]
               for i in range(len(bubbles_with_centers)-1)]

    if y_diffs:
        median_diff = np.median(y_diffs)
        row_threshold = median_diff * 0.6  # Threshold for considering bubbles in the same row
    else:
        row_threshold = 20  # Default threshold if we can't calculate

    # Group bubbles that have similar y values into rows
    rows = []
    current_row = [bubbles_with_centers[0]]

    for i in range(1, len(bubbles_with_centers)):
        # If the y-center is close to the previous bubble
        if abs(bubbles_with_centers[i][6] - current_row[0][6]) < row_threshold:
            current_row.append(bubbles_with_centers[i])
        else:
            rows.append(current_row)
            current_row = [bubbles_with_centers[i]]

    if current_row:
        rows.append(current_row)

    # Now sort each row by x-coordinate
    for i in range(len(rows)):
        rows[i].sort(key=lambda bubble: bubble[0])

    # This helps handle cases where there might be extra detected "bubbles"
    filtered_rows = []
    for row in rows:
        if len(row) >= num_options:
            # If we have more than expected, take the first num_options
            filtered_rows.append(row[:num_options])
        else:
            # If we have fewer than expected, keep what we have
            filtered_rows.append(row)

    # Verify we have the expected number of rows
    if len(filtered_rows) != num_questions:
        print(f"Warning: Expected {num_questions} questions but found {len(filtered_rows)} rows of bubbles")

    # Verify each row has the expected number of bubbles
    for i, row in enumerate(filtered_rows):
        if len(row) != num_options:
            print(f"Warning: Question {i+1} has {len(row)} options instead of expected {num_options}")

    return filtered_rows

def detect_filled_bubbles(image, organized_bubbles, debug=False):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    selected_answers = []


    debug_image = image.copy()

    for question_idx, row in enumerate(organized_bubbles):
        # If no bubbles were detected for this question, use a placeholder
        if not row:
            selected_answers.append('?')
            continue

        # Calculate the darkness of each bubble
        bubble_darkness = []

        for option_idx, (x, y, w, h, contour, area, _) in enumerate(row):
            # Create a mask
            mask = np.zeros(gray.shape, dtype=np.uint8)
            cv2.drawContours(mask, [contour], -1, 255, -1)

            # Calculate the mean intensity inside the bubble
            # Lower value = darker = more likely to be filled
            mean_intensity = cv2.mean(gray, mask=mask)[0]

            # Add a bias for expected bubble position
            bubble_darkness.append((option_idx, mean_intensity))

            # Draw rectangle for debugging
            if debug:
                cv2.rectangle(debug_image, (x, y), (x+w, y+h), (0, 255, 0), 2)
                cv2.putText(debug_image, f"{mean_intensity:.1f}", (x, y-5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)

        # Sort the bubbles by darkness
        # Determine if we should use a darkness threshold
        # Calculate average and standard deviation of bubble darkness
        intensities = [b[1] for b in bubble_darkness]
        avg_intensity = sum(intensities) / len(intensities) if intensities else 0

        # Calculate standard deviation
        if len(intensities) > 1:
            std_dev = (sum((x - avg_intensity) ** 2 for x in intensities) / len(intensities)) ** 0.5
        else:
            std_dev = 0

        # Sort the bubbles by darkness
        bubble_darkness.sort(key=lambda x: x[1])

        # The darkest bubble is the selected answer
        selected_option_idx = bubble_darkness[0][0]

        # Check if the darkest bubble is significantly darker than others
        threshold = avg_intensity - 1.5 * std_dev

        if bubble_darkness[0][1] < threshold:
            selected_option = chr(65 + selected_option_idx)  # 65 is ASCII for 'A'
        else:
            # If no bubble is significantly darker, consider it unanswered
            selected_option = chr(65 + selected_option_idx)

        selected_answers.append(selected_option)

        # Draw the selected bubble in blue for debugging
        if debug:
            x, y, w, h = row[selected_option_idx][0:4]
            cv2.rectangle(debug_image, (x, y), (x+w, y+h), (255, 0, 0), 3)

    if debug:
        show_image(debug_image, "Detected Answers")

    return selected_answers

def grade_answers(detected_answers, answer_key):

    score = 0
    detailed_results = []

    for i, (detected, correct) in enumerate(zip(detected_answers, answer_key)):
        is_correct = detected == correct
        if is_correct:
            score += 1

        detailed_results.append({
            'question': i + 1,
            'selected': detected,
            'correct': correct,
            'is_correct': is_correct
        })

    return score, detailed_results

def process_answer_sheet(image_path, answer_key, debug=False):
    """Main function to process an answer sheet and grade it"""
    # Preprocess the image
    original, gray, thresh = preprocess_image(image_path)

    if debug:
        show_image(original, "Original Image")
        show_image(gray, "Grayscale Image")
        show_image(thresh, "Thresholded Image")

    # Find potential bubbles
    bubbles = find_bubbles(thresh)

    # Organize bubbles into rows and columns
    organized_bubbles = organize_bubbles(bubbles)

    # Detect which bubbles are filled
    detected_answers = detect_filled_bubbles(original, organized_bubbles, debug=debug)

    # Grade the answers
    score, detailed_results = grade_answers(detected_answers, answer_key)

    # results
    total_questions = len(answer_key)
    return {
        'score': score,
        'total': total_questions,
        'percentage': (score / total_questions) * 100,
        'detected_answers': detected_answers,
        'detailed_results': detailed_results
    }

def display_results(results):
    """Display the grading results in a readable format"""
    print(f"\n===== GRADING RESULTS =====")
    print(f"Score: {results['score']}/{results['total']} ({results['percentage']:.1f}%)")
    print("\nDetailed Results:")
    print("-" * 40)
    print(f"{'Q#':<5}{'Selected':<10}{'Correct':<10}{'Result':<10}")
    print("-" * 40)

    for item in results['detailed_results']:
        result_mark = "✓" if item['is_correct'] else "✗"
        print(f"{item['question']:<5}{item['selected']:<10}{item['correct']:<10}{result_mark:<10}")

def visualize_graded_sheet(image_path, results):
    image = cv2.imread(image_path)
    if image is None:
        print(f"Error: Could not read image at {image_path}")
        return

    vis_image = image.copy()

    # Process the image to find bubbles
    _, gray, thresh = preprocess_image(image_path)
    bubbles = find_bubbles(thresh)
    organized_bubbles = organize_bubbles(bubbles)

    # Draw question numbers and correct/incorrect indicators
    for q_idx, question_row in enumerate(organized_bubbles):
        if q_idx >= len(results['detailed_results']):
            continue

        result = results['detailed_results'][q_idx]
        is_correct = result['is_correct']

        # Find the bubble that corresponds to the detected answer
        selected_option = ord(result['selected']) - ord('A')

        if 0 <= selected_option < len(question_row):
            x, y, w, h = question_row[selected_option][0:4]

            # Draw rectangle around selected answer
            color = (0, 255, 0) if is_correct else (0, 0, 255)  # Green if correct, Red if wrong
            cv2.rectangle(vis_image, (x-5, y-5), (x+w+5, y+h+5), color, 3)

            # If wrong, indicate the correct answer
            if not is_correct:
                correct_option = ord(result['correct']) - ord('A')
                if 0 <= correct_option < len(question_row):
                    cx, cy, cw, ch = question_row[correct_option][0:4]
                    # Draw rectangle around correct answer in blue
                    cv2.rectangle(vis_image, (cx-5, cy-5), (cx+cw+5, cy+ch+5), (255, 0, 0), 2)

        # Add question number and result at the left margin
        y_pos = question_row[0][1] + question_row[0][3]//2
        cv2.putText(vis_image, f"Q{q_idx+1}: {'✓' if is_correct else '✗'}",
                   (10, y_pos), cv2.FONT_HERSHEY_SIMPLEX, 0.7,
                   (0, 255, 0) if is_correct else (0, 0, 255), 2)

    # Add score at the top
    score_text = f"Score: {results['score']}/{results['total']} ({results['percentage']:.1f}%)"
    cv2.putText(vis_image, score_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX,
               1.0, (0, 0, 255), 2)

    show_image(vis_image, "Graded Answer Sheet")

    return vis_image

if __name__ == "__main__":

    answer_key = ['A', 'A', 'B', 'B', 'D']

    image_path = "/content/Exam_sheet1.jpeg"
    results = process_answer_sheet(image_path, answer_key, debug=True)

    display_results(results)

    visualize_graded_sheet(image_path, results)